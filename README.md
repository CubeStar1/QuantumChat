# Quantum Chat

Quantum Chat is a secure chat system that uses Quantum Key Distribution (QKD) for generating cryptographic keys and RSA for key exchange. It consists of a server-side component written in TypeScript and a client-side component written in Svelte.

## Server-side (TypeScript)

The server maintains two maps: `connections` and `nicknames`. `connections` maps nicknames and WebSocket URLs to their corresponding WebSocket connections. `nicknames` maps WebSocket connections to their corresponding nicknames.

When a new WebSocket connection is established, the server listens for incoming messages from the client. Depending on the message type ('nickname', 'conversation', or 'message'), the server performs different actions such as storing the nickname, generating a new key, or logging the message.

The server generates a new key using the `generateKey` function. This function makes a request to a Python script, which uses QKD to generate a secure cryptographic key. Once the key is generated, the server encrypts it with the public keys of the sender and recipient, creates two message objects, and sends them to the sender and recipient's WebSocket connections.

## Client-side (Svelte)

The client maintains a WebSocket connection (`socket`) to the server. It also has access to a local IndexedDB database (`db`) where it stores users and messages.

The client listens for messages from the server. When a message is received, it's parsed from JSON into an object. Depending on the type of the message, the client performs different actions such as logging the list of users, adding the message to the database, or starting a new conversation.

The `newConversation` function is used to start a new conversation with another user. It sends a message to the server with the type 'conversation' and the recipient's nickname. The server will then generate a new key and send it to both the sender and the recipient.

The `handleInput` and `stopTyping` functions are used to handle user typing events. When a user starts typing, a 'typing' message is sent to the server. After 1 second of inactivity, a 'stop typing' message is automatically sent.

## Hybrid Encryption

Quantum Chat uses a hybrid encryption system that combines the benefits of both symmetric and asymmetric encryption. The symmetric keys generated by the QKD API endpoint are shared between clients using RSA.

When a client connects to the server, it generates a new RSA key pair and sends the public key to the server. The server stores this public key and uses it to encrypt the symmetric key generated by the QKD API endpoint. The encrypted symmetric key is then sent to the client, who can decrypt it using their private key.

This hybrid encryption system ensures that even if the symmetric key is intercepted during transmission, it cannot be decrypted without the corresponding RSA private key. This adds an additional layer of security to the chat system.

## Symmetric Key Generation using QKD

The key generation is done using the `generate_key.py` script. This script defines a FastAPI application with a single GET endpoint `/key/{desired_key_length}`. This endpoint generates a shared key of a specified length using quantum computations. The generated key is then used in the Quantum Chat application to generate symmetric keys for encryption.

When a new conversation is started in the Quantum Chat application, a request is made to this endpoint with the desired key length. The endpoint then generates a shared key using quantum computations and returns it as a string. This key is then used for encrypting and decrypting messages in the chat conversation.

The server doesn't store the keys. They are generated on-demand for each new conversation and sent directly to the clients. This means that even if the server is compromised, the attacker won't be able to decrypt the messages because they won't have access to the keys.


## Encryption and Decryption of Symmetric Key

When a new conversation is initiated, the server sends an encrypted symmetric key to the clients involved in the conversation. This key is encrypted using the public keys of the sender and recipient. The clients then need to decrypt this symmetric key using their private keys. This process is handled in the client-side Svelte code.

In the `page.svelte` file, when a message of type `'conversation'` is received from the server, the client proceeds to decrypt the symmetric key. This is done using the `decryptSymmetricKey` function, which takes the encrypted symmetric key and the client's private key as arguments.

The `decryptSymmetricKey` function uses the RSA-OAEP algorithm for decryption. The decrypted symmetric key is then stored in the IndexedDB database along with the nickname of the other user in the conversation.

The `addRequest.onsuccess` and `addRequest.onerror` callbacks handle the success and error events of the add operation respectively. If the operation is successful, the new user is added to the `users` array and the page is reloaded. If an error occurs, it is logged to the console.

This process ensures that each client has the correct symmetric key for each conversation, allowing them to encrypt and decrypt messages securely.

## Encryption and Decryption of Messages

The encryption and decryption of messages are handled using the AES (Advanced Encryption Standard) algorithm, specifically the CTR (Counter) mode of operation. The AES-CTR mode of operation is used because it allows for encrypting and decrypting arbitrary lengths of messages, which is suitable for a chat application.

The encryption process happens in the `handleSubmit` function. The function checks if there's a message to send and a selected user to send it to. It then converts the selected user's key from a base64 string to a byte array, creates an AES-CTR cipher, and encrypts the message. The encrypted message is then sent to the server via a WebSocket connection.

The decryption process happens in the `decryptMessage` function. The function checks if the message is encrypted. If it is, it converts the user's key from a base64 string to a byte array, creates an AES-CTR cipher, and decrypts the message.

The server doesn't handle encryption or decryption. It simply relays messages between clients. The encryption and decryption are done client-side to ensure that even if someone intercepts the messages, they won't be able to read them without the correct key.


## Svelte Client Interface

The client interface is built using Svelte. It consists of a chat window where users can send and receive messages. The interface also displays the current user's nickname and provides a switch to toggle between different themes.

The `newConversation` function is used to start a new conversation with another user. It sends a message to the server with the type 'conversation' and the recipient's nickname. The server will then generate a new key and send it to both the sender and the recipient.

The `handleInput` and `stopTyping` functions are used to handle user typing events. When a user starts typing, a 'typing' message is sent to the server. After 1 second of inactivity, a 'stop typing' message is automatically sent.

The client interface also includes a `ThemeSwitcher` component that allows users to toggle between different themes. The current theme is stored in local storage, so it persists across page reloads.


## Running the Application

This application consists of a Svelte frontend and a TypeScript backend. The backend server makes requests to the key generation server to generate shared keys using quantum computations. Here's how you can run the application:

### Running the Svelte Frontend

1. Navigate to the frontend directory:

```bash
cd chatapp-frontend

```

2. Install the dependencies:

```bash
npm install
```

3. Start the development server:

```bash
npm run dev
```

4. You can also start the server and open the app in a new browser tab with `npm run dev -- --open`


### Running the TypeScript Backend

1. Navigate to the backend directory:

```bash
cd chatapp-server
```

2. Install the dependencies:

```bash
npm install
```

3. Start the server:
    
```bash
ts-node index_test2.ts
```

4. The server will listen on `ws://localhost:3000`. You can connect to it using the frontend application.


## Running the FastAPI Key Generation Server

The key generation server is a FastAPI application that generates shared keys using quantum computations. Here's how you can run it:

1. Navigate to the key generation server directory:

```bash
cd qkd-key-generation
```

2. Install the dependencies:

```bash
pip install -r requirements.txt
```

3. Start the server:

```bash
 uvicorn generate_key:app --host 0.0.0.0 --port 8000
```

4. The server will start running on `http://localhost:8000`. You can make requests to it to generate shared keys.

